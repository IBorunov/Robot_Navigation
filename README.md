# Robot Navigation
## Целью данного кода является разработка основы системы навигации для автономного робота, который должен самостоятельно передвигаться в заданной среде

# Установка и запуск
### Python 3.10
* Устанавливаем зависимости командой pip install -r requirements.txt
* Запускаем код из любой удобной среды разработки

# Описание и структура кода
### Код состоит из функций генерации карты, определения соседних узлов, функции реализации алгоритма А*, построения и оптимизации пути, а также функции для визуализации работы программы с использованием библиотеки matplotlib.

## Функция генерации карты def generate_map():
Генерирует карту и препятствия на ней
Принимает аргументы:
* size — размерность сетки (например, 10 означает сетку 10x10). Указывается ниже в основном блоке кода
* obstacle_chance — вероятность, с которой будет создаваться препятствие в ячейке. Именованный аргумент. Значение указываем в пределах 0,1-0,3. При значении выше есть риск невозможности нахождения пути от точки к точке.
Возвращает карту (_map)

## Функция нахождения соседних узлов def find_neighbouring_nodes():
Нужна для определения направления движения по карте и оценки сложности пути. Также реализует проверку на выход с карты
Принимает аргументы:
* node — текущий узел (точка).
* _map — карта.
Возвращает список соседних узлов (neighbours)
## Эвристическая функция для A* def heuristic():
Принимает аргументы:
* node — текущий узел.
* goal — конечный узел (цель).
Возвращает манхэттенское расстояние между текущим узлом и целью. Манхэттенское расстояние — это сумма модулей разницы координат по оси X и оси Y.

## Функция реализации алгоритма А* a_star():
Реализация алгоритма A* для поиска кратчайшего пути на сетке. 
Аргументы:
* _map : list of list of int - карта пространства в виде двумерной сетки
* start : tuple of int - стартовая позиция (x, y)
* goal : tuple of int - целевая позиция (x, y) 
### Возвращает list of tuple of int - содержащий кратчайший путь от start до goal, или пустой список, если путь не найден.

### Принцип работы функции:
### Инициализация:
* open_set — список открытых узлов, которые нужно проверить. Сначала добавляем стартовую точку с оценкой 0.
* came_from — словарь для отслеживания пути.
* g_score — словарь, содержащий стоимость пути от стартового узла до текущего. Начальная точка имеет стоимость 0.
* f_score — словарь, содержащий оценочную стоимость пути от стартового узла до конечного узла через текущую. Для начальной точки f_score равен эвристической оценке h(start, goal).
### Основной цикл:
* Пока есть узлы в open_set, выбираем узел current с наименьшей оценочной стоимостью f.
* Если current — целевой узел, вызываем reconstruct_path для восстановления полного пути и возвращаем его.
* Идем по всем соседним узлам neighbor текущего узла:
* Пропускаем узел, если он является препятствием.
* Рассчитываем предварительную стоимость пути tentative_g_score для соседа.
* Если узел не в g_score или новая стоимость (tentative_g_score) меньше текущей сохраненной стоимости, обновляем данные:
* Обновим came_from, g_score и f_score для соседа.
* Добавляем соседа в open_set с новой оценочной стоимостью f.
### Возврат пустого списка:
### Если open_set пуст, а целевой узел так и не был найден, функция вернет пустой список []. Соответственно путь не будет найден. Это может призойти в случае, если не существует доступного пути в точку: Например, если стартовый и конечный узлы отделены непреодолимыми препятствиями, функция не сможет найти путь.
## Чтобы этого избежать, рекомендуется указывать значение obstacle_chance функции def generate_map в диапазоне от 0,1 до 0,3.

## Функция генерации итогового пути def reconstruct_path():
Принимает два аргумента:
* Словарь came_from, который хранит информацию о том, откуда пришел конкретный узел;
* Узел current, который является конечным (целью).
В цикле while current in came_from проверяется, есть ли текущий узел в словаре came_from. Если да, то текущий узел заменяется на тот узел, откуда он пришел (т.е. предшественника), и добавляется в список path.
Таким образом, поэтапно идет обратное восстановление пути от цели к старту.

Возвращает восстановленный путь в правильном порядке.

## Функция оптимизации пути def minimize_turns():
Предназначена для оптимизации пути, полученного с помощью алгоритма A*, с целью уменьшения количества поворотов.
Функция принимает один аргумент:
* path: список координат (узлов) пути, который нужно оптимизировать. Каждая координата представлена в виде кортежа (x, y).

Сначала функция проверяет, не пуст ли входной список пути. Если путь пуст, функция сразу возвращает пустой список.
В основном цикле функции происходит следующее:
- Для каждого узла (начиная со второго) вычисляется `new_direction` — разница координат текущего узла и последнего добавленного в оптимизированный путь (`optimized_path[-1]`).
- Проверяется, изменилась ли `new_direction` относительно текущего `direction`.
- Если направление изменилось, это означает, что произошел поворот, и узел перед поворотом добавляется в `optimized_path`. Затем обновляется текущая `direction`.

После того как основной цикл завершен, добавляется последний узел оригинального пути в `optimized_path`, чтобы гарантировать, что конечная точка также включена в оптимизированный путь.

## Функция def visualize():
Параметры функции
- _map: Двумерный список, представляющий карту. Каждый элемент принимает значение 1 (препятствие) или 0 (свободная клетка).
- path: Список координат, представляющий найденный путь (например, результат алгоритма поиска пути A*).
- optimized_path: Список координат, представляющий оптимизированный путь (после упрощения первоначального пути)

Используем две вложенные петли for для прохода по каждой клетке карты.
- Если клетка является препятствием (_map[i][j] == 1), то задаем цвет пикселя как черный [0, 0, 0].
- В противном случае, пиксель остается белым [255, 255, 255].
- Проходим по списку path. Для каждой координаты (x, y) задаем цвет пикселя как синий [0, 0, 255].
- Проходим по списку optimized_path. Для каждой координаты (x, y) задаем цвет пикселя как зеленый [0, 255, 0].

## Основной блок кода
### Здесь задаются такие параметры как размер карты, начальная и конечная точки (_map, start, goal).

# Примеры выполнения кода
<p align="center">
<img src=https://github.com/IBorunov/Robot_Navigation/blob/main/0%2C1%20obstacle%2010%20size.png>
</p>
<p align="center"><i>Результат с картой 10х10 и 10% частотой припятствий </i></p>

<p align="center">
<img src=https://github.com/IBorunov/Robot_Navigation/blob/main/0.3%2C%20obstacles%2020%20size.png>
</p>
<p align="center"><i>Результат с картой 20х20 и 30% частотой припятствий </i></p>


<p align="center">
<img src=https://github.com/IBorunov/Robot_Navigation/blob/main/0%2C1%20obstacles%2030%20size.png>
</p>
<p align="center"><i>Результат с картой 30х30 и 20% частотой припятствий </i></p>


